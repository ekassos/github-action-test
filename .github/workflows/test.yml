# Copyright 2025 Evangelos Kassos
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: Generate Swift Book PDFs

on:
  workflow_dispatch:
    inputs:
      sha:
        description: 'Optional specific commit SHA of swift-book to build from'
        required: false

jobs:
  generate-pdfs:
    runs-on: macos-latest
    outputs:
      matrix: ${{ steps.missed_tags.outputs.matrix }}
      latest_sha: ${{ steps.fetch_target.outputs.latest_sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read stored swift-book commit SHA
        id: read_last_sha
        run: |
          if [ -f .github/sha ]; then
            echo "LAST_BUILT_SHA=$(cat .github/sha)" >> $GITHUB_ENV
          else
            echo "LAST_BUILT_SHA=" >> $GITHUB_ENV
          fi

      - name: Fetch target commit info
        id: fetch_target
        env:
          INPUT_SHA: ${{ github.event.inputs.sha }}
          GITHUB_API_TOKEN: ${{ github.token }}
        run: |
          if [ -n "$INPUT_SHA" ]; then
            INPUT_SHA_SHORT=$(echo "$INPUT_SHA" | cut -c1-7)
            echo "Using manually provided SHA: $INPUT_SHA_SHORT"
            COMMIT_JSON=$(curl -s -H "Authorization: Bearer $GITHUB_API_TOKEN" \
              "https://api.github.com/repos/swiftlang/swift-book/commits/$INPUT_SHA")
          else
            echo "Fetching latest commit from main..."
            COMMIT_JSON=$(curl -s -H "Authorization: Bearer $GITHUB_API_TOKEN" \
              "https://api.github.com/repos/swiftlang/swift-book/commits?sha=main&per_page=1")
            COMMIT_JSON=$(echo "$COMMIT_JSON" | jq '.[0]')
          fi

          LATEST_SHA=$(echo "$COMMIT_JSON" | jq -r '.sha')
          LATEST_SHA_SHORT=$(echo "$LATEST_SHA" | cut -c1-7)

          echo "LATEST_SHA=$LATEST_SHA" >> $GITHUB_ENV
          echo "LATEST_SHA_SHORT=$LATEST_SHA_SHORT" >> $GITHUB_ENV
          echo "latest_sha=$LATEST_SHA" >> $GITHUB_OUTPUT

      - name: Clone swift-book repo
        run: |
          git clone https://github.com/swiftlang/swift-book.git swift-book-repo
          cd swift-book-repo
          git fetch --tags

      - name: Find missed tagged commits
        id: missed_tags
        run: |
          cd swift-book-repo
          LAST_BUILT_SHA="$LAST_BUILT_SHA"
          TARGET_SHA="$LATEST_SHA"

          if [ -z "$LAST_BUILT_SHA" ]; then
            echo "First run: no previous SHA. Only building target commit."
          elif [ "$LAST_BUILT_SHA" = "$TARGET_SHA" ]; then
            echo "No new commits since last build. Skipping."
            echo 'matrix={"commits":[]}' >> $GITHUB_OUTPUT
            exit 0
          fi

          LAST_BUILT_SHA_SHORT=$(echo "$LAST_BUILT_SHA" | cut -c1-7)
          TARGET_SHA_SHORT=$(echo "$TARGET_SHA" | cut -c1-7)

          echo "Finding tags between $LAST_BUILT_SHA_SHORT and $TARGET_SHA_SHORT ..."
          MISSED_TAGS=$(git log --format=%H $LAST_BUILT_SHA..$TARGET_SHA | \
            xargs -I{} git tag --points-at {} | sort -u)

          echo "MISSED_TAGS<<EOF" >> $GITHUB_ENV
          echo "$MISSED_TAGS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          # Build JSON array for matrix: tagged commits first (oldest to newest), then target SHA
          # Sort tagged commits chronologically (oldest first) and convert to short SHAs
          if [ -n "$MISSED_TAGS" ]; then
            SORTED_TAG_SHAS=$(echo "$MISSED_TAGS" | while read tag; do
              if [ -n "$tag" ]; then
                COMMIT_SHA=$(git rev-list -n 1 "$tag")
                COMMIT_DATE=$(git show -s --format=%ct "$COMMIT_SHA")
                COMMIT_SHA_SHORT=$(echo "$COMMIT_SHA" | cut -c1-7)
                echo "$COMMIT_DATE $COMMIT_SHA_SHORT"
              fi
            done | sort -n | cut -d' ' -f2)
            TAGS_JSON=$(echo "$SORTED_TAG_SHAS" | jq -R . | jq -s .)
          else
            SORTED_TAG_SHAS=""
            TAGS_JSON="[]"
          fi

          echo "SORTED_TAG_SHAS:"
          echo "$SORTED_TAG_SHAS"

          echo "TAGS_JSON:"
          echo "$TAGS_JSON"

          echo "COMMITS_JSON:"
          echo "$COMMITS_JSON"
          
          # Create matrix with chronologically ordered short SHAs, ensuring no duplicates
          TARGET_SHA_SHORT=$(echo "$TARGET_SHA" | cut -c1-7)
          COMMITS_JSON=$(jq -n -c \
            --arg target "$TARGET_SHA_SHORT" \
            --argjson tags "$TAGS_JSON" \
            '{commits: ($tags + [$target]) | 
              reduce .[] as $c ([]; if index($c) then . else . + [$c] end)}')
          
          # Use the GITHUB_OUTPUT heredoc format to safely write multi-line or JSON outputs
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  build-pdfs:
    needs: generate-pdfs
    runs-on: macos-latest
    if: needs.generate-pdfs.outputs.matrix != '{"commits":[]}'
    strategy:
      matrix:
        sha: ${{ fromJson(needs.generate-pdfs.outputs.matrix).commits }}
      max-parallel: 1
    steps:
      - name: Skip if noop
        if: ${{ matrix.sha == 'noop' }}
        run: echo "No work to do"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update main branch and tags
        run: git checkout main && git pull --tags origin main

      - name: Check if SHA already built
        id: check_sha
        env:
          SHA: ${{ matrix.sha }}
        run: |
          if [ -f .github/sha ]; then
            LAST_BUILT_SHA=$(cat .github/sha)
            if [ "$SHA" = "$LAST_BUILT_SHA" ]; then
              SHA_SHORT=$(echo "$SHA" | cut -c1-7)
              echo "SHA $SHA_SHORT already built, skipping..."
              echo "skip=true" >> $GITHUB_OUTPUT
            else
              SHA_SHORT=$(echo "$SHA" | cut -c1-7)
              LAST_BUILT_SHA_SHORT=$(echo "$LAST_BUILT_SHA" | cut -c1-7)
              echo "SHA $SHA_SHORT is different from last built SHA $LAST_BUILT_SHA_SHORT, proceeding..."
              echo "skip=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "No previous SHA found, proceeding with build..."
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Download swift-book repo at commit
        if: steps.check_sha.outputs.skip != 'true'
        env:
          SHA: ${{ matrix.sha }}
        run: |
          git clone https://github.com/swiftlang/swift-book.git swift-book-repo
          cd swift-book-repo
          git checkout "$SHA"

      - name: Fetch specific swift-book commit SHA, message, and tag
        if: steps.check_sha.outputs.skip != 'true'
        id: swiftbook_sha
        env:
          SHA: ${{ matrix.sha }}
        run: |
          # Fetch commit info for the given SHA
          COMMIT_JSON=$(curl -s -H "Authorization: Bearer ${{ github.token }}" \
            "https://api.github.com/repos/swiftlang/swift-book/commits/$SHA")
          # Validate if
          if ! echo "$COMMIT_JSON" | jq -e 'has("sha")' > /dev/null; then
            echo "❌ Commit not found or invalid response:"
            echo "$COMMIT_JSON"
            exit 1
          fi
          LATEST_SHA_LOCAL=$(echo "$COMMIT_JSON" | jq -r '.sha')
          LATEST_SHA_SHORT=$(echo "$LATEST_SHA_LOCAL" | cut -c1-7)
          LATEST_MSG=$(echo "$COMMIT_JSON" | jq -r '.commit.message')
          COMMIT_DATE_RAW=$(echo "$COMMIT_JSON" | jq -r '.commit.author.date')
          echo "Commit SHA: $LATEST_SHA_SHORT"
          echo "Commit message: $LATEST_MSG"
          echo "Commit date (raw): $COMMIT_DATE_RAW"
          
          # Format commit date for display
          COMMIT_DATE=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$COMMIT_DATE_RAW" '+%B %d, %Y' 2>/dev/null || echo "$COMMIT_DATE_RAW")
          echo "Commit date (formatted): $COMMIT_DATE"
          
          # Export as env vars
          echo "LATEST_SHA=$LATEST_SHA_LOCAL" >> $GITHUB_ENV
          echo "LATEST_SHA_SHORT=$LATEST_SHA_SHORT" >> $GITHUB_ENV
          echo "LATEST_MSG<<EOF" >> $GITHUB_ENV
          echo "$LATEST_MSG" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "COMMIT_DATE=$COMMIT_DATE" >> $GITHUB_ENV
          # Export as outputs
          echo "latest_sha=$LATEST_SHA_LOCAL" >> $GITHUB_OUTPUT
          echo "latest_msg<<EOF" >> $GITHUB_OUTPUT
          echo "$LATEST_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "commit_date=$COMMIT_DATE" >> $GITHUB_OUTPUT
          # Save SHA to a file
          echo "$LATEST_SHA_LOCAL" > latest-swift-book-sha-latest.txt
          # Fetch tags that point to this commit
          TAG_JSON=$(curl -s -H "Authorization: Bearer ${{ github.token }}" \
            "https://api.github.com/repos/swiftlang/swift-book/tags")
          TAG_NAME=$(echo "$TAG_JSON" | jq -r --arg sha "$LATEST_SHA_LOCAL" '.[] | select(.commit.sha==$sha) | .name')
          echo "Tag name: $TAG_NAME"
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          
          # If we have a tag, fetch the release date from the GitHub API
          if [ -n "$TAG_NAME" ]; then
            echo "Fetching release date for tag: $TAG_NAME"
            RELEASE_JSON=$(curl -s -H "Authorization: Bearer ${{ github.token }}" \
              "https://api.github.com/repos/swiftlang/swift-book/git/tags/$LATEST_SHA_LOCAL")
            
            # Extract the published date from the release
            RELEASE_DATE=$(echo "$RELEASE_JSON" | jq -r '.published_at')
            if [ "$RELEASE_DATE" != "null" ] && [ -n "$RELEASE_DATE" ]; then
              FORMATTED_DATE=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$RELEASE_DATE" '+%B %d, %Y' 2>/dev/null || echo "$RELEASE_DATE")
              echo "Release date: $FORMATTED_DATE"
              echo "RELEASE_DATE=$RELEASE_DATE" >> $GITHUB_ENV
              echo "FORMATTED_DATE=$FORMATTED_DATE" >> $GITHUB_ENV
              echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
              echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
            else
              echo "No release date found, using commit date instead"
              # Fallback to commit date if no release date is found
              COMMIT_DATE=$(echo "$COMMIT_JSON" | jq -r '.commit.author.date')
              FORMATTED_DATE=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$COMMIT_DATE" '+%B %d, %Y' 2>/dev/null || echo "$COMMIT_DATE")
              echo "Commit date: $FORMATTED_DATE"
              echo "RELEASE_DATE=$COMMIT_DATE" >> $GITHUB_ENV
              echo "FORMATTED_DATE=$FORMATTED_DATE" >> $GITHUB_ENV
              echo "release_date=$COMMIT_DATE" >> $GITHUB_OUTPUT
              echo "formatted_date=$FORMATTED_DATE" >> $GITHUB_OUTPUT
            fi
          fi


      - name: Install TeX Live (cached)
        if: steps.check_sha.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/texlive
            ~/.texlive2025
          key: texlive-2025-${{ runner.os }}-${{ hashFiles('.github/workflows/generate-swift-book-pdfs.yml') }}
          restore-keys: |
            texlive-2025-${{ runner.os }}-

      - name: Install TeX Live and required packages
        if: steps.check_sha.outputs.skip != 'true'
        run: |
          set -e
          YEAR=2025
          TEXDIR="$HOME/texlive/${YEAR}"
          export PATH="$TEXDIR/bin/universal-darwin:$PATH"
          if ! command -v tlmgr >/dev/null 2>&1; then
            curl -L -o install-tl-unx.tar.gz http://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz
            tar -xzf install-tl-unx.tar.gz
            INSTALL_DIR=$(find . -maxdepth 1 -type d -name 'install-tl-*' | head -n 1)
            cd "$INSTALL_DIR"
            printf '%s\n' \
              'selected_scheme scheme-small' \
              "TEXDIR $TEXDIR" \
              "TEXMFCONFIG $HOME/.texlive2025/texmf-config" \
              "TEXMFHOME $HOME/texmf" \
              "TEXMFLOCAL $HOME/texlive/texmf-local" \
              "TEXMFSYSCONFIG $TEXDIR/texmf-config" \
              "TEXMFSYSVAR $TEXDIR/texmf-var" \
              "TEXMFVAR $HOME/.texlive2025/texmf-var" \
              'option_doc 0' \
              'option_src 0' \
              > texlive.profile
            ./install-tl -profile texlive.profile
            cd ..
          fi
          tlmgr update --self || true
          REQUIRED_PKGS="fontspec xcolor graphics fancyhdr geometry adjustbox ifoddpage enumitem listings minted tcolorbox pgf needspace hyperref parskip tabulary ragged2e footmisc lua-ul pdfcol tikzfill bigfoot"
          tlmgr install $REQUIRED_PKGS || true
          tlmgr path add
          echo "$TEXDIR/bin/universal-darwin" >> $GITHUB_PATH
          
          # Test LaTeX installation
          echo "Testing LaTeX installation..."
          echo '\documentclass{article}\begin{document}Test\end{document}' > test.tex
          if pdflatex test.tex > /dev/null 2>&1; then
            echo "✅ LaTeX installation successful"
            rm -f test.tex test.pdf test.log test.aux
          else
            echo "❌ LaTeX installation failed"
            exit 1
          fi

      - name: Generate PDFs
        if: steps.check_sha.outputs.skip != 'true'
        run: |
          mkdir -p swift-book/latest

          # Helper function to run commands quietly unless debug is enabled
          run_quiet() {
            if [ "$ACTIONS_STEP_DEBUG" = "true" ]; then
              "$@"
            else
              "$@" > /dev/null 2>&1
            fi
          }

          # Helper function to check if LaTeX compilation succeeded
          check_latex_success() {
            local tex_file="$1"
            local pdf_file="${tex_file%.tex}.pdf"
            if [ -f "$pdf_file" ]; then
              echo "✅ Successfully generated: $pdf_file"
              return 0
            else
              echo "❌ Failed to generate: $pdf_file"
              # Show the last few lines of the log file for debugging
              local log_file="${tex_file%.tex}.log"
              if [ -f "$log_file" ]; then
                echo "Last 10 lines of $log_file:"
                tail -10 "$log_file"
              fi
              return 1
            fi
          }

          # Function to compile LaTeX with error handling
          compile_latex() {
            local tex_file="$1"
            local output_dir="swift-book/latest"
            echo "Compiling $tex_file..."
            
            # First compilation
            if ! run_quiet pdflatex -output-directory="$output_dir" "$tex_file"; then
              echo "❌ First pdflatex run failed for $tex_file"
              return 1
            fi
            
            # Second compilation to resolve references
            if ! run_quiet pdflatex -output-directory="$output_dir" "$tex_file"; then
              echo "❌ Second pdflatex run failed for $tex_file"
              return 1
            fi
            
            # Check if PDF was generated
            if check_latex_success "$tex_file"; then
              return 0
            else
              return 1
            fi
          }

          # Generate digital light mode PDF
          echo "Generating digital light mode PDF..."
          cat > swift-book/latest/swift_book_digital.tex << 'EOF'
          \documentclass[12pt]{article}
          \usepackage{geometry}
          \usepackage{hyperref}
          \usepackage{parskip}
          \geometry{margin=1in}
          \title{Swift Book - Digital Edition}
          \author{Swift Documentation}
          \date{\today}
          \begin{document}
          \maketitle
          \section{Introduction}
          This is a test PDF generated from LaTeX instead of swift-book-pdf.
          \section{Content}
          Sample content for testing purposes.
          \end{document}
          EOF
          compile_latex "swift-book/latest/swift_book_digital.tex"

          # Generate digital dark mode PDF
          echo "Generating digital dark mode PDF..."
          cat > swift-book/latest/swift_book_digital_dark.tex << 'EOF'
          \documentclass[12pt]{article}
          \usepackage{geometry}
          \usepackage{hyperref}
          \usepackage{xcolor}
          \usepackage{parskip}
          \pagecolor{black}
          \color{white}
          \geometry{margin=1in}
          \title{Swift Book - Digital Dark Edition}
          \author{Swift Documentation}
          \date{\today}
          \begin{document}
          \maketitle
          \section{Introduction}
          This is a test dark mode PDF generated from LaTeX instead of swift-book-pdf.
          \section{Content}
          Sample content for testing purposes.
          \end{document}
          EOF
          compile_latex "swift-book/latest/swift_book_digital_dark.tex"

          # Generate print light mode PDF
          echo "Generating print light mode PDF..."
          cat > swift-book/latest/swift_book_print.tex << 'EOF'
          \documentclass[12pt]{article}
          \usepackage{geometry}
          \usepackage{hyperref}
          \usepackage{parskip}
          \geometry{margin=1.5in}
          \title{Swift Book - Print Edition}
          \author{Swift Documentation}
          \date{\today}
          \begin{document}
          \maketitle
          \section{Introduction}
          This is a test print PDF generated from LaTeX instead of swift-book-pdf.
          \section{Content}
          Sample content for testing purposes.
          \end{document}
          EOF
          compile_latex "swift-book/latest/swift_book_print.tex"

          # Generate print dark mode PDF
          echo "Generating print dark mode PDF..."
          cat > swift-book/latest/swift_book_print_dark.tex << 'EOF'
          \documentclass[12pt]{article}
          \usepackage{geometry}
          \usepackage{hyperref}
          \usepackage{xcolor}
          \usepackage{parskip}
          \pagecolor{black}
          \color{white}
          \geometry{margin=1.5in}
          \title{Swift Book - Print Dark Edition}
          \author{Swift Documentation}
          \date{\today}
          \begin{document}
          \maketitle
          \section{Introduction}
          This is a test print dark mode PDF generated from LaTeX instead of swift-book-pdf.
          \section{Content}
          Sample content for testing purposes.
          \end{document}
          EOF
          compile_latex "swift-book/latest/swift_book_print_dark.tex"

          # List generated files for debugging
          echo "Files in swift-book/latest/:"
          ls -la swift-book/latest/

          # Check for LaTeX auxiliary files and logs for debugging
          echo "LaTeX auxiliary files:"
          ls -la swift-book/latest/*.aux swift-book/latest/*.log 2>/dev/null || echo "No auxiliary files found"

          # Verify PDFs were generated
          PDF_COUNT=$(ls swift-book/latest/*.pdf 2>/dev/null | wc -l)
          echo "Generated $PDF_COUNT PDF files"
          
          if [ "$PDF_COUNT" -eq 0 ]; then
            echo "❌ No PDF files were generated!"
            echo "Checking for LaTeX errors in log files:"
            for log_file in swift-book/latest/*.log; do
              if [ -f "$log_file" ]; then
                echo "=== Contents of $log_file ==="
                cat "$log_file" | tail -20
                echo "=== End of $log_file ==="
              fi
            done
            exit 1
          fi

          # If this commit has a tag, also copy PDFs into that tag folder
          if [ -n "${{ steps.swiftbook_sha.outputs.tag_name }}" ]; then
            TAG_DIR="swift-book/${{ steps.swiftbook_sha.outputs.tag_name }}"
            mkdir -p "$TAG_DIR"
            echo "Copying PDFs from swift-book/latest/ to $TAG_DIR/"
            echo "Source files:"
            ls -la swift-book/latest/*.pdf
            cp swift-book/latest/*.pdf "$TAG_DIR"/
            echo "Also copied PDFs to $TAG_DIR"
            echo "Files in $TAG_DIR:"
            ls -la "$TAG_DIR"
          fi

          echo "All PDFs generated successfully!"

      - name: Commit and push PDFs via GitHub API (single commit, binary-safe, skip unchanged)
        id: commit_pdfs
        if: steps.check_sha.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = process.env.GITHUB_REF.replace("refs/heads/", "");

            // Build commit message
            const shaShort = process.env.LATEST_SHA_SHORT;
            const latestMsg = process.env.LATEST_MSG;
            const latestSha = process.env.LATEST_SHA;
            const tagName = process.env.TAG_NAME;
            const commitDate = process.env.COMMIT_DATE;

            let commitMessage = `Swift Book upstream: ${shaShort}
            ${latestMsg}

            Upstream commit: https://github.com/swiftlang/swift-book/commit/${latestSha}`;

            // Add tag and commit date information if available
            if (tagName && commitDate) {
              commitMessage += `\n\nTag: ${tagName} (commit date: ${commitDate})`;
            }

            // Collect files -> will become tree entries
            const treeEntries = [];

            async function addFile(filePath) {
              const contentBase64 = fs.readFileSync(filePath).toString("base64");

              // Create blob
              const { data: blob } = await github.rest.git.createBlob({
                owner,
                repo,
                content: contentBase64,
                encoding: "base64",
              });

              treeEntries.push({
                path: filePath,
                mode: "100644",
                type: "blob",
                sha: blob.sha,
              });
            }

            // Always include sha file
            const shaSrc = "latest-swift-book-sha-latest.txt";
            const shaDest = ".github/sha";

            // Overwrite/replace the .github/sha file
            fs.copyFileSync(shaSrc, shaDest);

            // Add the file to the tree
            await addFile(shaDest);

            // PDFs in latest/
            const latestDir = "swift-book/latest";
            if (fs.existsSync(latestDir)) {
              for (const file of fs.readdirSync(latestDir)) {
                if (file.endsWith(".pdf")) {
                  await addFile(path.join(latestDir, file));
                }
              }
            }

            // PDFs in tag folder
            if (tagName) {
              const tagDir = `swift-book/${tagName}`;
              if (fs.existsSync(tagDir)) {
                for (const file of fs.readdirSync(tagDir)) {
                  if (file.endsWith(".pdf")) {
                    await addFile(path.join(tagDir, file));
                  }
                }
              }
            }

            if (treeEntries.length === 0) {
              console.log("No files found to commit");
              return;
            }

            // 1. Get reference to current branch
            const { data: refData } = await github.rest.git.getRef({
              owner,
              repo,
              ref: `heads/${branch}`,
            });

            const latestCommitSha = refData.object.sha;

            // 2. Get commit object (to retrieve tree)
            const { data: commitData } = await github.rest.git.getCommit({
              owner,
              repo,
              commit_sha: latestCommitSha,
            });

            const baseTree = commitData.tree.sha;

            // 3. Create new tree
            const { data: newTree } = await github.rest.git.createTree({
              owner,
              repo,
              base_tree: baseTree,
              tree: treeEntries,
            });

            // 4. Check if new tree is identical to base
            if (newTree.sha === baseTree) {
              console.log("No changes detected — skipping commit");
              return;
            }

            // 5. Create new commit
            const { data: newCommit } = await github.rest.git.createCommit({
              owner,
              repo,
              message: commitMessage,
              tree: newTree.sha,
              parents: [latestCommitSha],
            });

            // 6. Update branch ref
            await github.rest.git.updateRef({
              owner,
              repo,
              ref: `heads/${branch}`,
              sha: newCommit.sha,
            });

            console.log("Commit created:", newCommit.sha);

            // Export commit SHA as an output
            core.setOutput("commit_sha", newCommit.sha);
        env:
          LATEST_SHA_SHORT: ${{ env.LATEST_SHA_SHORT }}
          LATEST_MSG: ${{ env.LATEST_MSG }}
          LATEST_SHA: ${{ env.LATEST_SHA }}
          TAG_NAME: ${{ steps.swiftbook_sha.outputs.tag_name }}
          COMMIT_DATE: ${{ steps.swiftbook_sha.outputs.commit_date }}

      - name: Tag commit if upstream is tagged (via GitHub API, overwrite if exists)
        if: steps.check_sha.outputs.skip != 'true' && steps.swiftbook_sha.outputs.tag_name != ''
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tagName = process.env.TAG_NAME;
            const commitSha = process.env.COMMIT_SHA; // ✅ direct from commit step
      
            // Create annotated tag object
            const { data: tag } = await github.rest.git.createTag({
              owner,
              repo,
              tag: tagName,
              message: `Tagging upstream release ${tagName}`,
              object: commitSha,
              type: "commit",
              tagger: {
                name: "github-actions[bot]",
                email: "41898282+github-actions[bot]@users.noreply.github.com",
                date: new Date().toISOString(),
              },
            });
      
            // Try to create or update the tag ref
            try {
              await github.rest.git.createRef({
                owner,
                repo,
                ref: `refs/tags/${tagName}`,
                sha: tag.sha,
              });
              console.log(`Created new tag ${tagName} → ${commitSha}`);
            } catch (err) {
              if (err.status === 422) {
                await github.rest.git.updateRef({
                  owner,
                  repo,
                  ref: `tags/${tagName}`,
                  sha: tag.sha,
                  force: true,
                });
                console.log(`Updated existing tag ${tagName} → ${commitSha}`);
              } else {
                throw err;
              }
            }
        env:
          TAG_NAME: ${{ steps.swiftbook_sha.outputs.TAG_NAME }}
          COMMIT_SHA: ${{ steps.commit_pdfs.outputs.commit_sha }}


      - name: Create release and upload PDFs if upstream is tagged
        if: steps.check_sha.outputs.skip != 'true' && steps.swiftbook_sha.outputs.TAG_NAME != ''
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.swiftbook_sha.outputs.TAG_NAME }}
          name: ${{ steps.swiftbook_sha.outputs.TAG_NAME }}
          body: |
            Release for Swift Book upstream tag ${{ steps.swiftbook_sha.outputs.TAG_NAME }}
            
            Originally released: ${{ steps.swiftbook_sha.outputs.formatted_date }}

            https://github.com/swiftlang/swift-book/releases/tag/${{ steps.swiftbook_sha.outputs.TAG_NAME }}
          files: |
            swift-book/${{ steps.swiftbook_sha.outputs.TAG_NAME }}/swift_book_digital.pdf
            swift-book/${{ steps.swiftbook_sha.outputs.TAG_NAME }}/swift_book_digital_dark.pdf
            swift-book/${{ steps.swiftbook_sha.outputs.TAG_NAME }}/swift_book_print.pdf
            swift-book/${{ steps.swiftbook_sha.outputs.TAG_NAME }}/swift_book_print_dark.pdf
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FORMATTED_DATE: ${{ steps.swiftbook_sha.outputs.formatted_date }}